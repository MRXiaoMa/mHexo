---
title: Andorid基本概念的理解
date: 2017-12-22 12:28:01
tags:
   - Java
   - Andorid
---
# 计算机基本概念的生活化理解
<!-- more -->
### 个人理解,计算机中的算法,概念,模型等,很多都可以在现实生活中找到与之匹配的场景.也就是说,我们在理解计算机为什么这样做的时候,不需要直接去看最后的实现结果,应该从原因导向,如果我们在现实生活中遇到了这样子的问题,你会怎么做,如此,很多看起来很高深莫测的技术,便也算能够理解了,这篇博客,会用通俗的方式来理解计算机的概念

# Java
2. 多态,多态的作用,消除类型之间的耦合关系,现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果,多态存在必须的三个条件.继承,重写,父类引用只想子类对象

# 多线程相关
1. 理解进程和线程,可以把进程看成公路,线程看成公路的一个车道,两个城市要连接,
必须要有路,也就是说程序要运行,必须要有进程,至于有几个车道,可以根据实际情况决定,但是每个车道的情况却又会影响别的车道,为了未定型,可以开启多进程(多条路),可以增加系统的稳定性
3. 线程的阻塞,本质上就是不同对象需要_改变_同一个资源时的排队等待现象,现实生活中这样的现象很多,如 不同的人要在同一个饮水机上接水(要从饮水机上得到水,同时饮水机会失去这部分水,可以认为是人对饮水机的水量的状态进行了改变),在调用`wait()`和`notify()`方式时必须满足以下情况,调用的位置必须是在`synchronized`方法中,该方法或块的上锁对象就是调用这一方法的对象,如不满足,运行时会抛出`IllegalMonitorStateException `异常,上面的内容的模拟代码如下
    ```
      synchronized(A){
        ...
        A.wait();
        // B.wait(); 这样写的话会抛出异常
        ...
      }

      synchronized(A){
        ...
        A.wait();
        A.notify();
        ...
      }
    ```
    在调用wait()方法时,该代码块放弃锁,进去到A(锁对象)的lock(阻塞)队列,然后在A的就绪队列中选取一个方法执行,然后第二个代码块执行,在第二个代码块中执行`A.wait()`方法时,第二个代码块会进入到A的阻塞队列,然后调用`A.notify()`方法,在A的就绪队列中选取一个(JVM控制,如何选取这块还不太了解,等待研究)获得锁执行
4. 线程同步基于两个基本概念 内存可见性和执行有序性([参考这里](http://www.iteye.com/topic/806990)) 
  - 内存可见性: 多线程中对于主线程的变量的操作会影响到所有线程中的主线程的该变量,java中的实现有两种:
    - synchronized 
      1. 从主内存复制变量到工作内存(read and load 读和加载)
      2. 执行代码,改变共享变量值(use and assign 操作和分配)
      3. 用工作内存数据刷新主内存的相关内容(store and write 通知和写)
    - volatile关键字
      该关键字修饰主内存中的变量,工作区中对于该变量的操作会立刻改变该变量(不需要拷贝到工作区),volatile关机字是线程同步的轻量级实现,由于其未实现执行有序性,在使用时要满足以下条件
      1. 对变量的写操作不依赖于当前值(即在线程中执行如下代码`a=b`,不能执行这样的`a*=10`)
      2. 该变量没有包含在具有其他变量的不变式中 (在线程中执行`c=a*2`等,这里a使用volatile修饰的)
  - 执行有序性 执行有序性的实现主要是synchronized关键字修饰代码块或者方法,可以给该代码块(方法)加锁,只有释放锁(wait)后,其他的代码块(方法)才会执行
